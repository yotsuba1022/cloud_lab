# Network ACL（ステートレス）vs Security Group（ステートフル）深掘り解析

[English](../en/03_network_acl_stateless_vs_security_group_stateful.md) | [繁體中文](../zh-tw/03_network_acl_stateless_vs_security_group_stateful.md) | [日本語](03_network_acl_stateless_vs_security_group_stateful.md) | [索引に戻る](../README.md)

---

## 核心概念の違い

### ステートレス（無状態）- Network ACL
**定義**：接続の状態や履歴を記憶または追跡しない

**主要特性**：
- 各パケットが**独立して検査される**
- 以前の関連するアウトバウンドリクエストを記憶しない
- インバウンドとアウトバウンドのルールが**完全に分離して処理される**
- 双方向のルールを明示的に設定する必要がある

### ステートフル（有状態）- Security Group
**定義**：接続の状態を記憶し追跡する

**主要特性**：
- アウトバウンドリクエストの接続状態を記憶する
- 対応するインバウンドレスポンストラフィックを**自動的に許可**
- 単方向のルール設定のみが必要
- 関連するトラフィックをインテリジェントに処理

## 実際の動作比較

### シナリオ：EC2が`https://google.com`にアクセス

#### 🔄 完全なTCP接続フロー
```
ステップ1: [EC2:32451] ---------> [Google:443] (SYN: 接続を確立したい)
ステップ2: [EC2:32451] <--------- [Google:443] (SYN-ACK: OK、受信しました)  
ステップ3: [EC2:32451] ---------> [Google:443] (ACK: 受信、接続確立)
ステップ4: [EC2:32451] ---------> [Google:443] (HTTP Request: ウェブページをください)
ステップ5: [EC2:32451] <--------- [Google:443] (HTTP Response: ウェブページのコンテンツです)
```

**説明**：
- `32451`はEC2がランダムに選択したephemeral port（1024-65535）
- `443`はGoogleのHTTPSサービスポート

### 🚫 Network ACL（ステートレス）の処理方法

**アウトバウンドルールの例**：
```hcl
egress {
  protocol   = "6"     # TCP
  rule_no    = 100
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 443
  to_port    = 443
}
```

**処理結果**：
- ✅ ステップ1、3、4（アウトバウンド）→ **通過許可**
- ❌ ステップ2、5（インバウンド）→ **拒否！** 

**根本原因**：
Network ACLがステップ2のパケットを見たとき：
> "142.251.42.142:443から10.0.1.10:32451へのパケットがある、インバウンドルールをチェックする必要がある...
> あれ、このソースを許可するルールがない、拒否！"

**追加必要なインバウンドルール**：
```hcl
# ephemeral portレスポンスを許可
ingress {
  protocol   = "6"     # TCP  
  rule_no    = 90
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 1024    # クライアントがランダムに選択するポート範囲
  to_port    = 65535
}

# HTTPSサービスポートレスポンスを許可
ingress {
  protocol   = "6"     # TCP
  rule_no    = 100
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 443
  to_port    = 443
}
```

### ✅ Security Group（ステートフル）の処理方法

**アウトバウンドルールの例**：
```hcl
egress {
  protocol    = "tcp"
  from_port   = 443
  to_port     = 443
  cidr_blocks = ["0.0.0.0/0"]
}
```

**処理結果**：
- ✅ ステップ1、3、4（アウトバウンド）→ **通過許可**
- ✅ ステップ2、5（インバウンド）→ **自動許可！**

**インテリジェント処理**：
Security Groupがステップ2のパケットを見たとき：
> "142.251.42.142:443から10.0.1.10:32451へのパケットがある...
> チェックしてみよう、あ！これは以前ポート32451から出た接続への応答だ、
> これは正当なレスポンストラフィックなので、通過許可！"

## 主要差異まとめ表

| 特性 | Network ACL（ステートレス）| Security Group（ステートフル）|
|------|----------------------------|------------------------------|
| **動作レベル** | サブネットレベル | インスタンスレベル |
| **接続記憶** | ❌ 接続状態を記憶しない | ✅ 接続状態を記憶する |
| **ルール要件** | 双方向ルールを設定する必要 | 単方向ルールのみ必要 |
| **レスポンス処理** | レスポンストラフィックを明示的に許可する必要 | 関連レスポンスを自動許可 |
| **デフォルト動作** | デフォルトですべて拒否 | デフォルトでインバウンド拒否、アウトバウンド許可 |
| **ルール評価** | ルール番号順で評価 | すべてのルールを評価（OR論理）|
| **適用範囲** | サブネット内のすべてのリソース | 特定のEC2インスタンス |

## Ephemeral Portsの重要性

### Ephemeral Portsとは？

**定義**：クライアントが接続を開始する際にランダムに選択する一時的なポート

**範囲**：
- Linux/Windows: 1024-65535
- 一部の新しいシステム: 32768-65535

### なぜEphemeral Portsを許可する必要があるのか？

```
実際の接続例：
EC2 (IP: 10.0.1.10, Port: 32451) → Google (IP: 142.251.42.142, Port: 443)
EC2 (IP: 10.0.1.10, Port: 32451) ← Google (IP: 142.251.42.142, Port: 443)
```

**Network ACLが見るレスポンスパケット**：
- **ソース**: 142.251.42.142:443
- **宛先**: 10.0.1.10:32451

ポート32451を許可するインバウンドルールがない場合、このレスポンスはブロックされます。

### 一般的なEphemeral Port設定

```hcl
# すべてのephemeral portsを許可（ほとんどの場合に推奨）
ingress {
  protocol   = "6"
  rule_no    = 90
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 1024
  to_port    = 65535
}

# 一般的な範囲のみ許可（より制限的）
ingress {
  protocol   = "6"
  rule_no    = 90
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 32768
  to_port    = 65535
}
```

## よくある問題と解決策

### 問題1：pingは出せるが応答がない

**症状**：
```bash
$ ping www.google.com
# 応答なし、ネットワークが到達不可能に見える
```

**原因**：
```
ICMP Echo Request  (アウトバウンド) ✅ → 許可
ICMP Echo Reply    (インバウンド)  ❌ → Network ACLによってブロック
```

**解決策**：
```hcl
# ICMP応答を許可
ingress {
  protocol   = "1"  # ICMP
  rule_no    = 80
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 0
  to_port    = 0
  icmp_type  = -1
  icmp_code  = -1
}
```

### 問題2：HTTPS接続がハング

**症状**：
```bash
$ curl https://google.com
# ハングしてタイムアウト
```

**原因**：
- TCP SYNは送信可能
- TCP SYN-ACK応答がブロック
- 3ウェイハンドシェイクが完了できない

**解決策**：
```hcl
# ephemeral port応答を許可
ingress {
  protocol   = "6"
  rule_no    = 90
  action     = "allow"
  cidr_block = "0.0.0.0/0"
  from_port  = 1024
  to_port    = 65535
}
```

### 問題3：内部サービス間でアクセスできない

**症状**：
同じVPC内のサービス同士が接続できない

**解決策**：
```hcl
# VPC内部通信を許可
ingress {
  protocol   = "-1"  # すべてのプロトコル
  rule_no    = 110
  action     = "allow"
  cidr_block = var.vpc_cidr  # 例：10.0.0.0/16
  from_port  = 0
  to_port    = 0
}

egress {
  protocol   = "-1"
  rule_no    = 120
  action     = "allow"
  cidr_block = var.vpc_cidr
  from_port  = 0
  to_port    = 0
}
```

## ベストプラクティス推奨事項

### Network ACL設計原則

1. **双方向通信を優先的に考慮**
   - すべてのアウトバウンドルールに対応するインバウンドルールが必要
   - ephemeral port範囲に特に注意

2. **重要なルールには低いルール番号を使用**
   - Network ACLはルール番号順で評価
   - 低い番号が先に評価される

3. **不要なトラフィックを明示的に拒否**
   - 明示的な拒否ルールを使用
   - デフォルトのdeny allに依存しない

### Security Group設計原則

1. **最小権限の原則**
   - 必要なポートとソースのみを開放
   - 不要なルールを定期的に見直しとクリーンアップ

2. **説明的なルール名を使用**
   - 各ルールの目的を明確に示す
   - 将来のメンテナンスとデバッグを容易にする

## 記憶の手がかり

### Network ACL（ステートレス）
> **「健忘症の患者」**
> 
> "さっき何を言ったか覚えていない、すべてのパケットをルールに対してチェックする必要がある！
>  入りたい？パスを見せて！出たい？パスを見せて！"

### Security Group（ステートフル）
> **「思いやりのある執事」**
> 
> "あなたの前回のリクエストを覚えています、すでに認証されて出て行ったので、
>  あなたの応答は直接入ってこれます、再チェックは不要です！"

## まとめ

**ステートレス** vs **ステートフル**の違いを理解することは、AWSネットワークセキュリティをマスターする鍵です：

- **Network ACL**は厳格な国境検問所のようなもので、出入りする人は皆証明書をチェックされる
- **Security Group**はインテリジェントなアクセス制御システムのようなもので、誰が出て行ったかを記憶し、自動的に戻ることを許可する

「送信できるが応答を受信できない」問題に遭遇した場合、十中八九Network ACLのステートレス特性が原因です！ 